-- This script was generated by the ERD tool in pgAdmin 4.
-- Please log an issue at https://github.com/pgadmin-org/pgadmin4/issues/new/choose if you find any bugs, including reproduction steps.
BEGIN;

-- DROP TABLES for quick script execution (DO NOT DELETE THE ARCHIVES)
DROP TABLE IF EXISTS public.rent CASCADE;
DROP TABLE IF EXISTS public.booking CASCADE;
DROP TABLE IF EXISTS public.room CASCADE;
DROP TABLE IF EXISTS public.customer CASCADE;
DROP TABLE IF EXISTS public.employee CASCADE;
DROP TABLE IF EXISTS public.hotel CASCADE;
DROP TABLE IF EXISTS public.hotelchain CASCADE;

CREATE TABLE IF NOT EXISTS public.hotelchain
(
    hotelChainID SERIAL PRIMARY KEY,
	hotelName VARCHAR(200) NOT NULL,
    numberofhotels INTEGER CHECK(numberofhotels > 0) -- Create a trigger to make sure that the hotels don't exceed this number
);

CREATE TABLE IF NOT EXISTS public.hotelchainaddress -- Multivalue attribute for hotelchain's address of offices
(
	addressID SERIAL PRIMARY KEY,
	streetNumber INTEGER,
	streetName VARCHAR(100),
	city VARCHAR(100),
	stateOrProvince VARCHAR(100),
	zip VARCHAR(10) CHECK (LENGTH(zip) BETWEEN 5 AND 6),
	fk_hotelChainID INTEGER NOT NULL,
	FOREIGN KEY (fk_hotelChainID) REFERENCES hotelchain(hotelChainID) ON DELETE CASCADE -- The referenced row will be deleted when parent is deleted
);

CREATE TABLE IF NOT EXISTS public.hotelchainemail -- Multivalue attribute for hotelchain's email addresses
(
	emailID SERIAL PRIMARY KEY,
	fk_hotelChainID INTEGER NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
	FOREIGN KEY (fk_hotelChainID) REFERENCES hotelchain(hotelChainID) ON DELETE CASCADE -- The referenced row will be deleted when parent is deleted
);

CREATE TABLE IF NOT EXISTS public.hotelchainphone -- Multivalue attribute for hotelchain's phone
(
	phoneID SERIAL PRIMARY KEY,
	fk_hotelChainID INTEGER NOT NULL,
    phoneNumber VARCHAR(20) UNIQUE NOT NULL CHECK (LENGTH(phoneNumber) BETWEEN 7 AND 20),
	FOREIGN KEY (fk_hotelChainID) REFERENCES hotelchain(hotelChainID) ON DELETE CASCADE -- The referenced row will be deleted when parent is deleted
);

CREATE TABLE IF NOT EXISTS public.hotel
(
    hotelID SERIAL PRIMARY KEY,
	fk_hotelChainID INTEGER NOT NULL,
    rating INTEGER CHECK (rating BETWEEN 0 AND 5), -- 0 to 5 stars (inclusive)
    numOfRooms INTEGER,

	-- Composite attributes of hotel's address
	streetNumber INTEGER,
	streetName VARCHAR(100),
	city VARCHAR(100),
	stateOrProvince VARCHAR(100),
	zip VARCHAR(10) CHECK (LENGTH(zip) BETWEEN 5 AND 6),
	
	FOREIGN KEY (fk_hotelChainID) REFERENCES hotelchain(hotelChainID) 
);

CREATE TABLE IF NOT EXISTS public.hotelemail -- Multivalue attribute for hotel's email addresses
(
	emailID SERIAL PRIMARY KEY,
	fk_hotelID INTEGER NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
	FOREIGN KEY (fk_hotelID) REFERENCES hotel(hotelID) ON DELETE CASCADE -- The referenced row will be deleted when parent is deleted
);

CREATE TABLE IF NOT EXISTS public.hotelphone -- Multivalue attribute for hotel's phone
(
	phoneID SERIAL PRIMARY KEY,
	fk_hotelID INTEGER NOT NULL,
    phoneNumber VARCHAR(20) UNIQUE NOT NULL CHECK (LENGTH(phoneNumber) BETWEEN 7 AND 20),
	FOREIGN KEY (fk_hotelID) REFERENCES hotel(hotelID) ON DELETE CASCADE -- The referenced row will be deleted when parent is deleted
);

CREATE TABLE IF NOT EXISTS public.room
(
    roomID SERIAL PRIMARY KEY,
    fk_hotelID INTEGER NOT NULL, -- Shouldn't be SERIAL
    price integer CHECK (price > 0),
    capacity integer CHECK (capacity >= 1),
    avail BOOLEAN,
    expandability VARCHAR(255),
    roomView VARCHAR(30),
    damage VARCHAR(255),
    FOREIGN KEY (fk_hotelID) REFERENCES hotel(hotelID)
);

CREATE TABLE IF NOT EXISTS public.roomamenities -- Multivalue attribute for room's ameneties
(
	amenityID SERIAL PRIMARY KEY,
	fk_roomID INTEGER NOT NULL,
	amenityName VARCHAR(100) NOT NULL,
	FOREIGN KEY (fk_roomID) REFERENCES room(roomID) ON DELETE CASCADE, -- The referenced row will be deleted when parent is deleted
	CONSTRAINT unique_room_amenity UNIQUE (fk_roomID, amenityName) -- Ensuring uniqueness for each room's amenity
);

CREATE TABLE IF NOT EXISTS public.employee
(
    employeeID SERIAL PRIMARY KEY,
    managerID INTEGER, -- Making it SERIAL means it increments each creation, which makes every employee a manager
    fk_hotelID INTEGER NOT NULL, 
    ename VARCHAR(50) NOT NULL,
    FOREIGN KEY (managerID) REFERENCES employee(employeeID),
	FOREIGN KEY (fk_hotelID) REFERENCES hotel(hotelID) -- Needs their hotel affiliation
);

CREATE TABLE IF NOT EXISTS public.employeeaddress -- Multivalue attribute for employee's address
(
	addressID SERIAL PRIMARY KEY,
	streetNumber INTEGER,
	streetName VARCHAR(100),
	city VARCHAR(100),
	stateOrProvince VARCHAR(100),
	zip VARCHAR(10) CHECK (LENGTH(zip) BETWEEN 5 AND 6),
	fk_employeeID INTEGER NOT NULL,
	FOREIGN KEY (fk_employeeID) REFERENCES employee(employeeID) ON DELETE CASCADE -- The referenced row will be deleted when parent is deleted
);

CREATE TABLE IF NOT EXISTS public.customer
(
	customerID SERIAL PRIMARY KEY, -- Auto-incrementing primary key
	cname VARCHAR(50) NOT NULL,
	registrationDate DATE DEFAULT CURRENT_DATE
);

CREATE TABLE IF NOT EXISTS public.customeraddress -- Multivalue attribute for customer's address
(
	addressID SERIAL PRIMARY KEY,
	streetNumber INTEGER,
	streetName VARCHAR(100),
	city VARCHAR(100),
	stateOrProvince VARCHAR(100),
	zip VARCHAR(10) CHECK (LENGTH(zip) BETWEEN 5 AND 6),
	fk_customerID INTEGER NOT NULL,
	FOREIGN KEY (fk_customerID) REFERENCES customer(customerID) ON DELETE CASCADE -- The referenced row will be deleted when parent is deleted
);

CREATE TABLE IF NOT EXISTS public.booking
(
	bookingID SERIAL PRIMARY KEY, -- Auto-incrementing primary key
	fk_customerID INTEGER NOT NULL,
	fk_roomID INTEGER,
	FOREIGN KEY (fk_customerID) REFERENCES customer(customerID),
	FOREIGN KEY (fk_roomID) REFERENCES room(roomID)
	
);

CREATE TABLE IF NOT EXISTS public.rent
(
	rentID SERIAL PRIMARY KEY, -- Auto-incrementing primary key
	checkInDate DATE NOT NULL,
	checkOutDate DATE NOT NULL,
	fk_roomID INTEGER NOT NULL, -- Do not put SERIAL on FKs
	fk_employeeID INTEGER NOT NULL,
	fk_customerID INTEGER NOT NULL,
	fk_bookingID INTEGER, -- Customer can walk in
	FOREIGN KEY (fk_roomID) REFERENCES room(roomID),
	FOREIGN KEY (fk_employeeID) REFERENCES employee(employeeID),
	FOREIGN KEY (fk_customerID) REFERENCES customer(customerID),
	FOREIGN KEY (fk_bookingID) REFERENCES booking(bookingID)
);

-- Create a trigger for rent/booking to be copied into each respective archive below
CREATE TABLE IF NOT EXISTS public.rent_archive
(
	rentArchiveID SERIAL PRIMARY KEY, -- Auto-incrementing primary key
	rentID INTEGER NOT NULL,
	checkInDate DATE NOT NULL,
	checkOutDate DATE NOT NULL,
	fk_roomID INTEGER NOT NULL, -- Do not forget the FKs
	fk_employeeID INTEGER NOT NULL,
	fk_customerID INTEGER NOT NULL,
	fk_bookingID INTEGER
);

CREATE TABLE IF NOT EXISTS public.booking_archive
(
	bookingArchiveID SERIAL PRIMARY KEY, -- Auto-incrementing primary key
	bookingID INTEGER NOT NULL,
	fk_customerID INTEGER NOT NULL, -- Do not forget the FKs
	fk_roomID INTEGER
);

-- Trigger functions
CREATE OR REPLACE FUNCTION check_num_hotels() RETURNS TRIGGER AS $$
	BEGIN
		-- current number of hotels for a certain hotel chain >= numberofhotels value of that ceratin hotelchain
		IF (SELECT COUNT(*) FROM hotel WHERE fk_hotelChainID = NEW.fk_hotelChainID) >= (SELECT numberofhotels FROM hotelchain WHERE hotelChainID = NEW.fk_hotelChainID) THEN 
			RAISE EXCEPTION 'Number of hotels has been exceeded'; -- Out of bounds of the numberofhotels
		END IF;

		RETURN NEW; -- Proceed with insertion
	END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER enforce_hotel_limit
BEFORE INSERT ON hotel
FOR EACH ROW
EXECUTE FUNCTION check_num_hotels();

CREATE OR REPLACE FUNCTION copy_to_booking_archive() RETURNS TRIGGER AS $$
	BEGIN
    	-- Insert all booking details into booking_archive immediately after insertion
	    INSERT INTO public.booking_archive (bookingID, fk_customerID, fk_roomID)
   		VALUES (NEW.bookingID, NEW.fk_customerID, NEW.fk_roomID);
		
    RETURN NEW; -- Return the newly inserted row (not needed but Postgres requires)
	END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER enforce_booking_archive
AFTER INSERT ON booking
FOR EACH ROW
EXECUTE FUNCTION copy_to_booking_archive();

CREATE OR REPLACE FUNCTION copy_to_rent_archive() RETURNS TRIGGER AS $$
	BEGIN
    	-- Insert all booking details into rent_archive immediately after insertion
	    INSERT INTO public.rent_archive (rentID, checkInDate, checkOutDate, fk_roomID, fk_employeeID, fk_customerID, fk_bookingID)
   		VALUES (NEW.rentID, NEW.checkInDate, NEW.checkOutDate, NEW.fk_roomID, NEW.fk_employeeID, NEW.fk_customerID, NEW.fk_bookingID);
		
    RETURN NEW; -- Return the newly inserted row (not needed but Postgres requires)
	END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER enforce_rent_archive
AFTER INSERT ON rent
FOR EACH ROW
EXECUTE FUNCTION copy_to_rent_archive();

-- Implementin views
CREATE VIEW room_available_per_area AS -- rooms available within an area 
SELECT h.zip, COUNT(*) AS availableRooms
FROM hotel AS h 
JOIN room AS r ON h.hotelID = r.fk_hotelID
WHERE r.avail = TRUE
GROUP BY h.zip;

CREATE VIEW room_capacity_per_hotel AS -- capacity of each room per hotel
SELECT h.hotelID, SUM(r.capacity) AS capacityOfAllRooms
FROM hotel AS h 
JOIN room AS r ON h.hotelID = r.fk_hotelID
GROUP BY h.hotelID;

END;


